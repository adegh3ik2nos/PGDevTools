#include <iostream>  
#include <pcl/ModelCoefficients.h>  
#include <pcl/io/pcd_io.h>  
#include <pcl/point_types.h>  
#include <pcl/sample_consensus/method_types.h>  
#include <pcl/sample_consensus/model_types.h>  
#include <pcl/visualization/cloud_viewer.h>  
#include <pcl/ModelCoefficients.h>  
#include <pcl/point_types.h>  
#include <pcl/io/pcd_io.h>  
#include <pcl/features/normal_3d.h>  
#include <pcl/filters/extract_indices.h>  
#include <pcl/filters/voxel_grid.h>  
#include <pcl/kdtree/kdtree.h>  
#include <pcl/sample_consensus/method_types.h>  
#include <pcl/sample_consensus/model_types.h>  
#include <pcl/segmentation/sac_segmentation.h>  
#include <pcl/segmentation/extract_clusters.h>  
#include <pcl/visualization/cloud_viewer.h>  
#include <pcl/surface/convex_hull.h>
#include "./rabv.hpp"
#include <iostream>

template <typename ... Args>
std::string format(const std::string& fmt, Args ... args)
{
	size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);
	std::vector<char> buf(len + 1);
	std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);
	return std::string(&buf[0], &buf[0] + len);
}

using namespace std;

int
main(int argc, char** argv)
{
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);

	// Fill in the cloud data  
	cloud->width = 50;
	cloud->height = 50;
	cloud->points.resize(cloud->width * cloud->height);

	// Generate the data  
	{
		size_t i;
		for (i = 0; i < cloud->points.size(); ++i)
		{
			// 平面におく  
			cloud->points[i].x = 1024 * rand() / (RAND_MAX + 1.0);
			cloud->points[i].y = 1024 * rand() / (RAND_MAX + 1.0);
			cloud->points[i].z = 1024 * rand() / (RAND_MAX + 1.0);
		}
	}





/*
	pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
	pcl::PointIndices::Ptr inliers(new pcl::PointIndices);*/
	// Create the segmentation object  
	//pcl::SACSegmentation<pcl::PointXYZ> seg;
	//// Optional  
	//seg.setOptimizeCoefficients(true);
	//// Mandatory  
	//seg.setModelType(pcl::SACMODEL_PLANE);
	//seg.setMethodType(pcl::SAC_RANSAC);
	//seg.setDistanceThreshold(0.1);

	pcl::PointCloud<pcl::PointXYZ> hull;
	std::vector<pcl::Vertices> polygons;

	pcl::ConvexHull<pcl::PointXYZ> chull;
	chull.setInputCloud(cloud);
	chull.setDimension(3);
	chull.reconstruct(hull, polygons);

	//PolygonMesh convex;
	//toPCLPointCloud2 (hull, convex.cloud);
	//convex.polygons = polygons;
	//saveVTKFile ("./test/bun0-convex.vtk", convex);

	std::cerr << "ver num: " << hull.size() << std::endl;
	for (std::size_t i = 0; i < hull.size(); ++i)
	{
		cout << hull[i] << endl;

	}


	auto rab = rabv::Rab::create();
	for (std::size_t i = 0; i < polygons.size(); ++i)
	{
		const pcl::Vertices & face1 = polygons[i];
		for (std::size_t j = 0; j < face1.vertices.size(); ++j)
		{
			rabv::Lines line1;
			line1.addLine(
				hull[face1.vertices[j]], // Point (x, y, z) for "from"
				hull[face1.vertices[(j + 1) %3]]  // Point (x, y, z) for "to"
			);
			
			rab->addLines(
				format("line%d_%d", i, j), // Unique name of the lines
				line1    // rabv::Lines
			);
		}
	}


	//pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_plane(new pcl::PointCloud<pcl::PointXYZ>());

	//float rgbs[5][3]
	//{
	   // {255, 0, 0},
	   // {0, 255, 0},
	   // {0, 0, 255},
	   // {128, 128, 0},
	   // {0, 128, 1280},
	//};

	//std::vector< pcl::PointXYZ> pnts[5];

	//int idx = 0;
	//int nr_points = cloud->points.size();
	//while (cloud->points.size() > 0.1 * nr_points)
	//{
	   // // Segment the largest planar component from the remaining cloud  
	   // seg.setInputCloud(cloud);
	   // seg.segment(*inliers, *coefficients); //*  
	   // if (inliers->indices.size() == 0)
	   // {
		  //  PCL_ERROR("Could not estimate a planar model for the given dataset.");
		  //  return (-1);
	   // }

	   // int n = inliers->indices.size();

	   // for (size_t i = 0; i < inliers->indices.size(); ++i) {
		  //  std::cerr << inliers->indices[i] << "    " << cloud->points[inliers->indices[i]].x << " "
		  //	  << cloud->points[inliers->indices[i]].y << " "
		  //	  << cloud->points[inliers->indices[i]].z << std::endl;
		  //  cloud->points[inliers->indices[i]].r = rgbs[idx][0];
		  //  cloud->points[inliers->indices[i]].g = rgbs[idx][1];
		  //  cloud->points[inliers->indices[i]].b = rgbs[idx][2];

		  //  pnts[idx].push_back(cloud->points[inliers->indices[i]]);
	   // }

	   // // Extract the planar inliers from the input cloud  
	   // pcl::ExtractIndices<pcl::PointXYZ> extract;
	   // extract.setInputCloud(cloud);
	   // extract.setIndices(inliers);
	   // extract.setNegative(false);

	   // // Write the planar inliers to disk  
	   // extract.filter(*cloud_plane); //*  
	   // std::cout << "PointCloud representing the planar component: " << cloud_plane->points.size() << " data points." << std::endl;

	   // // Remove the planar inliers, extract the rest  
	   // extract.setNegative(true);
	   // extract.filter(*cloud); //*  


	   // ++idx;
	//}


	//std::cerr << "Model coefficients: " << coefficients->values[0] << " "
	   // << coefficients->values[1] << " "
	   // << coefficients->values[2] << " "
	   // << coefficients->values[3] << std::endl;

	//std::cerr << "Model inliers: " << inliers->indices.size() << std::endl;
	//pcl::visualization::CloudViewer viewer("Cloud Viewer");

	//int allSize = 0;
	//for (int j = 0; j < idx; ++j)
	//{
	   // allSize += pnts[j].size();
	//}
	//cloud->points.resize(allSize);
	//int s = 0;
	//for (int j = 0; j < idx; ++j)
	//{
	   // for (int k = 0; k < pnts[j].size(); ++k)
	   // {
		  //  cloud->points[s + k] = pnts[j][k];
		  //  std::cerr
		  //	  << pnts[j][k].x << " "
		  //	  << pnts[j][k].y << " "
		  //	  << pnts[j][k].z << std::endl;
	   // }
	   // s += pnts[j].size();
	//}
/*
	viewer.showCloud(cloud->makeShared());

	while (!viewer.wasStopped())
	{

	}*/

	// 9. Visualze the rab data while the window is closed
	const auto& viewer1 = rabv::Viewer::create(
		"Viewer1",	// Title of viewer
		rab			// Rab data
	);
	viewer1->spinLoop();



	return (0);



#if 0

	pcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZRGB>());
	tree->setInputCloud(cloud);
	std::vector<pcl::PointIndices> cluster_indices;
	pcl::EuclideanClusterExtraction<pcl::PointXYZRGB> ec;
	ec.setClusterTolerance(10); // 2cm 
	ec.setMinClusterSize(2);
	ec.setMaxClusterSize(6);
	ec.setSearchMethod(tree);
	ec.setInputCloud(cloud);
	ec.extract(cluster_indices);

	/*pcl::NormalEstimation<pcl::PointXYZRGB, pcl::Normal> ne;
	ne.setInputCloud(cloud);
	pcl::search::KdTree<pcl::PointXYZRGB>::Ptr treeNorm(new pcl::search::KdTree<pcl::PointXYZRGB>());
	ne.setSearchMethod(treeNorm);
	pcl::PointCloud<pcl::Normal>::Ptr cloud_normals(new pcl::PointCloud<pcl::Normal>);
	ne.setRadiusSearch(0.03);
	ne.compute(*cloud_normals);*/

	int j = 0;
	float colors[6][3] = { {255, 0, 0}, {0,255,0}, {0,0,255}, {255,255,0}, {0,255,255}, {255,0,255} };
	for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices.begin(); it != cluster_indices.end(); ++it)
	{
		for (std::vector<int>::const_iterator pit = it->indices.begin(); pit != it->indices.end(); pit++) {
			cloud->points[*pit].r = colors[j % 6][0];
			cloud->points[*pit].g = colors[j % 6][1];
			cloud->points[*pit].b = colors[j % 6][2];
		}
		++j;
	}
#else

}
